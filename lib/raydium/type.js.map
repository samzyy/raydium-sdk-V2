{"version":3,"sources":["../../src/raydium/type.ts"],"sourcesContent":["import { PublicKey, Signer, Transaction, TransactionInstruction, VersionedTransaction, Keypair } from \"@solana/web3.js\";\r\nimport BN from \"bn.js\";\r\nimport { getTransferFeeConfig, Mint } from \"@solana/spl-token\";\r\nimport { MultiTxExecuteParam, TxBuilder } from \"../common/txTool/txTool\";\r\nimport { TokenAmount } from \"../module/amount\";\r\n\r\nexport interface ReturnTypeMakeInstructions<T = Record<string, PublicKey>> {\r\n  signers: (Signer | Keypair)[];\r\n  instructions: TransactionInstruction[];\r\n  instructionTypes: string[];\r\n  address: T;\r\n  lookupTableAddress: string[];\r\n}\r\n\r\nexport type SignAllTransactions =\r\n  | (<T extends Transaction | VersionedTransaction>(transaction: T[]) => Promise<T[]>)\r\n  | undefined;\r\n\r\nexport interface MakeTransaction<T = Record<string, any>> {\r\n  builder: TxBuilder;\r\n  signers: Signer[];\r\n  transaction: Transaction;\r\n  instructionTypes: string[];\r\n  execute: () => Promise<{ txId: string; signedTx: Transaction }>;\r\n  extInfo: T;\r\n}\r\n\r\nexport interface MakeV0Transaction<T = Record<string, any>> {\r\n  builder: TxBuilder;\r\n  signers: Signer[];\r\n  transaction: VersionedTransaction;\r\n  instructionTypes: string[];\r\n  execute: () => Promise<string>;\r\n  extInfo: T;\r\n}\r\n\r\nexport interface MakeMultiTransaction {\r\n  builder: TxBuilder;\r\n  signers: Signer[][];\r\n  transactions: Transaction[];\r\n  instructionTypes: string[];\r\n  execute: (params?: MultiTxExecuteParam) => Promise<{\r\n    txIds: string[];\r\n    signedTxs: Transaction[];\r\n  }>;\r\n  extInfo: Record<string, any>;\r\n}\r\n\r\nexport interface InstructionReturn {\r\n  instruction: TransactionInstruction;\r\n  instructionType: string;\r\n}\r\n\r\nexport interface ComputeBudgetConfig {\r\n  units?: number;\r\n  microLamports?: number;\r\n}\r\n\r\nexport interface TxTipConfig {\r\n  feePayer?: PublicKey;\r\n  address: PublicKey;\r\n  amount: BN;\r\n}\r\n\r\nexport interface LoadParams {\r\n  forceUpdate?: boolean;\r\n}\r\n\r\nexport interface TransferAmountFee {\r\n  amount: TokenAmount;\r\n  fee: TokenAmount | undefined;\r\n  expirationTime: number | undefined;\r\n}\r\nexport interface GetTransferAmountFee {\r\n  amount: BN;\r\n  fee: BN | undefined;\r\n  expirationTime: number | undefined;\r\n}\r\n\r\n// export type ReturnTypeFetchMultipleMintInfo = Mint & { feeConfig: TransferFeeConfig | undefined };\r\nexport type ReturnTypeFetchMultipleMintInfo = Mint & { feeConfig: ReturnType<typeof getTransferFeeConfig> | undefined };\r\nexport interface ReturnTypeFetchMultipleMintInfos {\r\n  [mint: string]: ReturnTypeFetchMultipleMintInfo & { programId: PublicKey };\r\n}\r\n\r\ntype Primitive = boolean | number | string | null | undefined | PublicKey;\r\n\r\n/**\r\n *\r\n * @example\r\n * ```typescript\r\n * interface A {\r\n *   keyA: string;\r\n *   keyB: string;\r\n *   map: {\r\n *     hello: string;\r\n *     i: number;\r\n *   };\r\n *   list: (string | number)[];\r\n *   keyC: number;\r\n * }\r\n *\r\n * type WrappedA = ReplaceType<A, string, boolean> // {\r\n *   keyA: boolean;\r\n *   keyB: boolean;\r\n *   map: {\r\n *     hello: boolean;\r\n *     i: number;\r\n *   };\r\n *   list: (number | boolean)[];\r\n *   keyC: number;\r\n * }\r\n * ```\r\n */\r\nexport type ReplaceType<Old, From, To> = {\r\n  [T in keyof Old]: Old[T] extends From // to avoid case: Old[T] is an Object,\r\n  ? Exclude<Old[T], From> | To // when match,  directly replace\r\n  : Old[T] extends Primitive // judge whether need recursively replace\r\n  ? From extends Old[T] // it's an Object\r\n  ? Exclude<Old[T], From> | To // directly replace\r\n  : Old[T] // stay same\r\n  : ReplaceType<Old[T], From, To>; // recursively replace\r\n};\r\n\r\nexport type MayArray<T> = T | Array<T>;\r\n\r\nexport type MayDeepArray<T> = T | Array<MayDeepArray<T>>;\r\n\r\nexport type MayFunction<T, PS extends any[] = []> = T | ((...Params: PS) => T);\r\n\r\nexport type ArrayItem<T extends ReadonlyArray<any>> = T extends Array<infer P> ? P : never;\r\n\r\nexport type ExactPartial<T, U> = {\r\n  [P in Extract<keyof T, U>]?: T[P];\r\n} & {\r\n  [P in Exclude<keyof T, U>]: T[P];\r\n};\r\n\r\nexport type ExactRequired<T, U> = {\r\n  [P in Extract<keyof T, U>]-?: T[P];\r\n} & {\r\n  [P in Exclude<keyof T, U>]: T[P];\r\n};\r\n\r\n/**\r\n * extract only string and number\r\n */\r\nexport type SKeyof<O> = Extract<keyof O, string>;\r\n\r\nexport type GetValue<T, K> = K extends keyof T ? T[K] : undefined;\r\n/**\r\n * @example\r\n * type A = { a: number; b: string; c?: string }\r\n * type B = { a: string; c: string; d?: boolean }\r\n *\r\n * type D = SOR<A, B> // { a: number | string; b: string | undefined; c: string | undefined; d: boolean | undefined } // ! if use SOR, you lost union type guard feature, try NOT to use this trick\r\n */\r\nexport type SOR<T, U> = { [K in keyof T | keyof U]: GetValue<T, K> | GetValue<U, K> };\r\n\r\nexport type Fallback<T, FallbackT> = T extends undefined ? FallbackT : T;\r\n\r\n/**\r\n * @example\r\n * type A = { a: number; b: string; c?: string }\r\n * type B = { a: string; c: string; d?: boolean }\r\n *\r\n * type D = Cover<A, B> // { a: string; b: string; c: string; d?: boolean}\r\n */\r\nexport type Cover<O, T> = { [K in SKeyof<O> | SKeyof<T>]: Fallback<GetValue<T, K>, GetValue<O, K>> };\r\n\r\nexport type UnionCover<O, T> = T extends T ? Cover<O, T> : never;\r\n\r\ntype MergeArr<Arr> = (Arr extends (infer T)[] ? T : never)[];\r\n\r\n/**\r\n * typescript type helper function\r\n * @example\r\n * type A = { hello: string; version: 3 }[]\r\n * type B = { hello: string; version: 5 }[]\r\n * type OK = MergeArr<A | B> // ({ hello: string; version: 3 } | { hello: string; version: 5 })[]\r\n * type Wrong = A | B // { hello: string; version: 3 }[] | { hello: string; version: 5 }[] // <= this type can't have auto type intelligense of array.map\r\n */\r\nexport const unionArr = <T>(arr: T): MergeArr<T> => arr as unknown as MergeArr<T>;\r\n"],"mappings":"4ZAAA,mDAsLO,GAAM,GAAW,AAAI,GAAwB","names":[]}